<!DOCTYPE _ [
<!ENTITY v1_adc_cols "trigger processingEndTime fluorescenceLow fluoresenceHigh scatteringLow scatteringHigh comparatorPulse triggerOpenTime frameGrabTime bottom left height width byteOffset valveStatus">
<!ENTITY v1_adc_types "int float float float float float float float float int int int int int double">
<!ENTITY v2_adc_cols "trigger processingEndTime pmtA pmtB pmtC pmtD peakA peakB peakC peakD timeOfFlight grabTimeStart frameGrabTime bottom left height width byteOffset comparatorOut startPoint signalStrength valveStatus">
<!ENTITY v2_adc_types "int float float float float float float float float float float float float int int int int int float int int int">
]>
<namespace name="ifcb">
  <!-- general regular expressions -->
  <rule name="re">
    <!-- identifier with no _ or . allowed (examples: "foo", "bar", "mp3") -->
    <var name="re.id">([a-zA-Z][a-zA-Z0-9]*)</var>
    <!-- extension (example ".jpg", ".mp3") matching everything but the period -->
    <var name="re.ext">(?:\.${re.id})</var>
    <!-- integer (zero-padding allowed) -->
    <var name="re.int">([0-9]+)</var>
  </rule>
  <rule name="pid" uses="pid">
    <!-- separate namespace part from rest of pid -->
    <match var="pid" pattern="(.*/)?(.*)" groups="namespace suffix"/>
    <!-- if there's a namespace, extract just the namespace's lid -->
    <!-- e.g., http://foo.bar.edu/baz/ has an lid of baz -->
    <match var="namespace" pattern="(?:.*/)?(.*)/$" groups="ts_label" optional="true"/>
    <!-- first, parse ID to determine IFCB schema version and extract timestamp -->
    <first>
      <!-- IFCB v1 ID syntax -->
      <match var="suffix" timestamp="(IFCB1_(yyyy_YYY_HHMMSS))(any)" groups="lid timestamp tpe">
	<var name="schema_version">v1</var>
	<var name="adc_cols">&v1_adc_cols;</var>
	<var name="instrument">${n1}</var>
	<var name="year">${yyyy}</var>
	<var name="yearday">${yyyy}_${YYY}</var>
	<var name="timestamp_format">%Y_%j_%H%M%S</var>
      </match>
      <!-- IFCB v2 ID syntax -->
      <match var="suffix" timestamp="(D(yyyymmddTHHMMSS)_IFCB111)(any)" groups="lid timestamp tpe">
	<var name="schema_version">v2</var>
	<var name="adc_cols">&v2_adc_cols;</var>
	<var name="instrument">${n1}</var>
	<var name="year">${yyyy}</var>
	<var name="yearday">${yyyy}${mm}${dd}</var>
	<var name="timestamp_format">%Y%m%dT%H%M%S</var>
      </match>
    </first>
    <var name="bin_lid">${lid}</var>
    <!-- now get any _target_product.extension -->
    <all include="lid target product extension">
      <invoke rule="ifcb.re"/>
      <var name="re.target">(?:_${re.int})</var>
      <var name="re.product">(?:_([a-zA-Z][a-zA-Z0-9_]*))</var>
      <!-- default product is raw -->
      <var name="product">raw</var>
      <match var="tpe" pattern="${re.target}?${re.product}?${re.ext}?"
	     groups="target product extension"/>
      <match var="target" optional="true">
	<var name="lid">${lid}_${target}</var>
      </match>
    </all>
  </rule>
  <namespace name="adc">
    <!-- return the column scheme for a given schema -->
    <rule name="schema" uses="schema_version">
      <first>
	<test var="schema_version" eq="v1">
	  <var name="columns">&v1_adc_cols;</var>
	  <var name="types">&v1_adc_types;</var>
	</test>
	<test var="schema_version" eq="v2">
	  <var name="columns">&v2_adc_cols;</var>
	  <var name="types">&v2_adc_types;</var>
	</test>
      </first>
    </rule>
    <!-- given an ADC file and a schema version, return all the targets as solutions -->
    <rule name="parse" uses="adc_file schema_version">
      <all count="targetNumber">
	<first>
	  <test var="schema_version" eq="v1">
	    <csv file="${adc_file}" vars="&v1_adc_cols;"/>
	  </test>
	  <test var="schema_version" eq="v2">
	    <csv file="${adc_file}" vars="&v2_adc_cols;"/>
	  </test>
	</first>
      </all>
    </rule>
    <!-- given an ADC file, schema version, and target number, return that target -->
    <rule name="get_target" uses="adc_file schema_version target">
      <invoke rule="ifcb.adc.parse" using="adc_file schema_version" nth="${target}" retain=" "/>
    </rule>
    <rule name="get_targets" uses="adc_file schema_version">
      <invoke rule="ifcb.adc.parse" using="adc_file schema_version" retain=" "/>
      <test var="height" gt="0"/>
      <test var="width" gt="0"/>
    </rule>
  </namespace>
  <namespace name="files">
    <!-- given a parsed pid including extension, and a root directory,
	 return all possible candidate paths -->
    <rule name="raw_path">
      <var name="filename">${bin_lid}.${extension}</var>
      <any>
	<!-- schema-dependent directory structures -->
	<first>
	  <test var="schema_version" eq="v1">
	    <var name="raw_path">${root}/IFCB${instrument}_${yearday}/${filename}</var>
	  </test>
	  <test var="schema_version" eq="v2">
	    <var name="raw_path">${root}/D${year}/D${yearday}/${filename}</var>
	  </test>
	</first>
	<!-- alternately, a flat directory structure -->
	<var name="raw_path">${root}/${filename}</var>
      </any>
    </rule>
    <rule name="find_raw_file" nth="1">
      <invoke rule="ifcb.files.raw_path"/>
      <path match="${raw_path}"/>
    </rule>
    <rule name="find_raw_fileset" include="hdr_path adc_path roi_path">
      <var name="extension">hdr</var>
      <invoke rule="ifcb.files.find_raw_file" rename="raw_path" as="hdr_path"/>
      <all>
	<var name="extension">
	  <val>adc</val>
	  <val>adc.mod</val>
	</var>
	<invoke rule="ifcb.files.find_raw_file" rename="raw_path" as="adc_path"/>
      </all>
      <var name="extension">roi</var>
      <invoke rule="ifcb.files.find_raw_file" rename="raw_path" as="roi_path"/>
    </rule>
    <rule name="list_raw_filesets" uses="root">
      <!-- strategy: list hdr files, then look for corresponding adc and roi files -->
      <any>
	<var name="data_dir">${root}</var>
	<path var="data_dir" match="${root}/IFCB*"/>
	<path var="year_dir" match="${root}/D*">
	  <path var="data_dir" match="${year_dir}/D*"/>
	</path>
      </any>
      <path var="hdr_path" match="${data_dir}/*.hdr"/>
      <match var="hdr_path" pattern="(.*/(.*))\.hdr$" groups="basename lid"/>
      <!-- look for other files in the same dir -->
      <path var="roi_path" match="${basename}.roi"/>
      <any>
	<path var="adc_path" match="${basename}.adc"/>
	<!-- FIXME needs to also work with .adc.mod files -->
      </any>
    </rule>
    <!-- products -->
    <rule name="product_path">
      <first>
	<test var="product" eq="blobs">
	  <var name="product_path">${root}/${year}/${yearday}/${bin_lid}_blobs_v2.zip</var>
	</test>
	<test var="product" eq="features">
	  <var name="product_path">${root}/features${year}_v2/${bin_lid}_fea_v2.csv</var>
	</test>
      </first>
    </rule>
    <rule name="find_product">
      <invoke rule="ifcb.files.product_path"/>
      <path match="${product_path}"/>
    </rule>
    <!-- detecting data directories -->
    <rule name="validate_data_dir" uses="root product" nth="1">
      <first>
	<!-- raw filesets -->
	<test var="product" eq="raw">
	  <!-- try each extension -->
	  <split group="extension" value="adc hdr roi"/>
	  <var name="name_glob">*.${extension}</var>
	  <!-- try flat, v1, and v2 directory layouts -->
	  <any>
	    <path match="${root}/${name_glob}"/>
	    <path match="${root}/IFCB[0-9]_[0-9]*_[0-9]*/${name_glob}"/> <!-- FIXME test -->
	    <path match="${root}/D[0-9]*/D[0-9]*/${name_glob}"/> <!-- FIXME test -->
	  </any>
	</test>
	<!-- blobs -->
	<test var="product" eq="blobs">
	  <var name="name_glob">*_blobs_v*.zip</var>
	  <!-- try the yyyy/yyyymmdd directory layout -->
	  <path match="${root}/[0-9]*/[0-9]*/${name_glob}"/>
	</test>
	<test var="product" eq="features">
	  <var name="name_glob">*_fea_v*.csv</var>
	  <!-- try the featuresyyyy_vn directory layout -->
	  <path match="${root}/features[0-9]*_v[0-9]*/${name_glob}"/>
	</test>
      </first>
    </rule>
    <rule name="find_data_dirs" uses="root" distinct="directory product">
      <!-- identify all data directories including their product type -->
      <any>
	<all include="directory product" nth="1">
	  <!-- use the validate_data_dir on each product type -->
	  <split group="product" value="raw blobs features"/>
	  <invoke rule="ifcb.files.validate_data_dir" rename="root" as="directory"/>
	</all>
	<!-- recursively descend into any subdirectories -->
	<all>
	  <path var="root" match="${root}/*/"/>
	  <invoke rule="ifcb.files.find_data_dirs" include="directory product"/>
	</all>
      </any>
    </rule>
  </namespace>
</namespace>
